/*
 File Header (auto-generated by scripts/add-file-headers.ts)
 - File: services/loan.service 2.ts
 - Purpose: Domain service for data access and business logic.
 - Context: Mediates between API routes/UI and the database layer.
 - How it works: Implements domain logic and orchestrates database calls with clear input/output types. Uses: Drizzle ORM.
 - External imports: drizzle-orm
 - Local imports: @/db/client, @/db/schema, @/types/loan, @/types/loan-document, @/types/loan-note, @/lib/loan-state-machine
 - Refactoring ideas: Define transaction boundaries explicitly. | Return typed result objects instead of throwing. | Isolate DB access behind repository helpers.
 - Security considerations: Use parameterized queries to prevent injection. | Do not log sensitive data. | Handle concurrency and race conditions explicitly.
*/
import { eq, and, desc } from "drizzle-orm";
import { db } from "@/db/client";
import { loans, borrowers, lenders, properties, loanDocuments, loanNotes, borrowerLoans, lenderLoans } from "@/db/schema";
import type { CreateLoanDTO, UpdateLoanDTO, Loan, LoanWithRelations } from "@/types/loan";
import type { LoanDocument, CreateLoanDocumentDTO } from "@/types/loan-document";
import type { LoanNote, CreateLoanNoteDTO, UpdateLoanNoteDTO } from "@/types/loan-note";
import { LoanStatus, BorrowerRole, LenderRole } from "@/types/loan";
import { canTransition } from "@/lib/loan-state-machine";

export class LoanService {
  /**
   * Create a new loan (v2 with hybrid model support)
   * Automatically populates junction tables for primary borrower/lender
   */
  static async createLoan(data: CreateLoanDTO): Promise<Loan> {
    const [loan] = await db
      .insert(loans)
      .values({
        organizationId: data.organizationId,
        loanCategory: data.loanCategory || "asset_backed",
        borrowerId: data.borrowerId || null,
        lenderId: data.lenderId || null,
        propertyId: data.propertyId || null,
        propertyAddress: data.propertyAddress || null,
        // v2 fields (required)
        principal: data.principal.toString(),
        rate: data.rate.toString(),
        termMonths: data.termMonths,
        paymentType: data.paymentType || "amortized",
        paymentFrequency: data.paymentFrequency || "monthly",
        originationFeeBps: data.originationFeeBps || 0,
        lateFeeBps: data.lateFeeBps || 0,
        defaultInterestBps: data.defaultInterestBps || 0,
        escrowEnabled: data.escrowEnabled || false,
        createdBy: data.createdBy || null,
        // Backward compatibility fields
        loanAmount: (data.loanAmount || data.principal).toString(),
        interestRate: (data.interestRate || data.rate).toString(),
        status: data.status || "draft",
        statusChangedAt: new Date(),
        fundedDate: data.fundedDate || null,
        maturityDate: data.maturityDate || null,
      })
      .returning();

    // Hybrid Model: Populate junction tables with primary entities
    if (data.borrowerId) {
      await db.insert(borrowerLoans).values({
        borrowerId: data.borrowerId,
        loanId: loan.id,
        role: BorrowerRole.PRIMARY,
        isPrimary: true,
      }).onConflictDoNothing();
    }

    if (data.lenderId) {
      await db.insert(lenderLoans).values({
        lenderId: data.lenderId,
        loanId: loan.id,
        role: LenderRole.PRIMARY,
        isPrimary: true,
        percentage: "100", // Primary lender has 100% by default
      }).onConflictDoNothing();
    }

    return loan as Loan;
  }

  /**
   * Get loan by ID
   */
  static async getLoanById(id: string): Promise<Loan | null> {
    const [loan] = await db.select().from(loans).where(eq(loans.id, id)).limit(1);

    return (loan as Loan) || null;
  }

  /**
   * Get all loans for an organization
   */
  static async getLoansByOrganization(organizationId: string): Promise<Loan[]> {
    const result = await db.select().from(loans).where(eq(loans.organizationId, organizationId));

    return result as Loan[];
  }

  /**
   * Update a loan
   */
  static async updateLoan(id: string, data: UpdateLoanDTO): Promise<Loan | null> {
    const updateData: Record<string, unknown> = {};

    if (data.borrowerId !== undefined) updateData.borrowerId = data.borrowerId;
    if (data.lenderId !== undefined) updateData.lenderId = data.lenderId;
    if (data.propertyId !== undefined) updateData.propertyId = data.propertyId;
    if (data.propertyAddress !== undefined) updateData.propertyAddress = data.propertyAddress;
    if (data.loanAmount !== undefined) updateData.loanAmount = data.loanAmount.toString();
    if (data.interestRate !== undefined) updateData.interestRate = data.interestRate.toString();
    if (data.termMonths !== undefined) updateData.termMonths = data.termMonths;
    if (data.status !== undefined) updateData.status = data.status;
    if (data.fundedDate !== undefined) updateData.fundedDate = data.fundedDate;
    if (data.maturityDate !== undefined) updateData.maturityDate = data.maturityDate;

    updateData.updatedAt = new Date();

    const [loan] = await db.update(loans).set(updateData).where(eq(loans.id, id)).returning();

    return (loan as Loan) || null;
  }

  /**
   * Delete a loan
   */
  static async deleteLoan(id: string): Promise<boolean> {
    await db.delete(loans).where(eq(loans.id, id));
    return true;
  }

  /**
   * Get loan with all related entities (Hybrid Model v2)
   * Fetches primary entities (FK) + all borrowers/lenders (junction tables)
   */
  static async getLoanWithRelations(id: string): Promise<LoanWithRelations | null> {
    const loan = await this.getLoanById(id);
    if (!loan) return null;

    const result: LoanWithRelations = { ...loan };

    // Fetch primary borrower if exists (for backward compatibility)
    if (loan.borrowerId) {
      const [borrower] = await db
        .select({
          id: borrowers.id,
          firstName: borrowers.firstName,
          lastName: borrowers.lastName,
          email: borrowers.email,
        })
        .from(borrowers)
        .where(eq(borrowers.id, loan.borrowerId))
        .limit(1);
      result.borrower = borrower;
    }

    // Fetch primary lender if exists (for backward compatibility)
    if (loan.lenderId) {
      const [lender] = await db
        .select({
          id: lenders.id,
          name: lenders.name,
          entityType: lenders.entityType,
        })
        .from(lenders)
        .where(eq(lenders.id, loan.lenderId))
        .limit(1);
      result.lender = lender;
    }

    // Fetch property if exists
    if (loan.propertyId) {
      const [property] = await db
        .select({
          id: properties.id,
          address: properties.address,
          city: properties.city,
          state: properties.state,
          propertyType: properties.propertyType,
        })
        .from(properties)
        .where(eq(properties.id, loan.propertyId))
        .limit(1);
      result.property = property;
    }

    // Hybrid Model: Fetch ALL borrowers (primary + co-borrowers)
    const allBorrowers = await db
      .select({
        id: borrowers.id,
        firstName: borrowers.firstName,
        lastName: borrowers.lastName,
        name: borrowers.name,
        email: borrowers.email,
        role: borrowerLoans.role,
        isPrimary: borrowerLoans.isPrimary,
      })
      .from(borrowerLoans)
      .innerJoin(borrowers, eq(borrowerLoans.borrowerId, borrowers.id))
      .where(eq(borrowerLoans.loanId, id));
    
    result.allBorrowers = allBorrowers.map(b => ({
      ...b,
      role: b.role as BorrowerRole,
    }));

    // Hybrid Model: Fetch ALL lenders (primary + participants)
    const allLenders = await db
      .select({
        id: lenders.id,
        name: lenders.name,
        entityType: lenders.entityType,
        contactEmail: lenders.contactEmail,
        role: lenderLoans.role,
        isPrimary: lenderLoans.isPrimary,
        percentage: lenderLoans.percentage,
      })
      .from(lenderLoans)
      .innerJoin(lenders, eq(lenderLoans.lenderId, lenders.id))
      .where(eq(lenderLoans.loanId, id));
    
    result.allLenders = allLenders.map(l => ({
      ...l,
      role: l.role as LenderRole,
    }));

    return result;
  }

  /**
   * Transition loan status with validation
   */
  static async transitionLoanStatus(
    id: string,
    newStatus: LoanStatus
  ): Promise<Loan | null> {
    // Get current loan
    const loan = await this.getLoanById(id);
    if (!loan) return null;

    // Validate transition
    const currentStatus = loan.status as LoanStatus;
    if (!canTransition(currentStatus, newStatus)) {
      throw new Error(
        `Invalid status transition from ${currentStatus} to ${newStatus}`
      );
    }

    // Update status
    const [updatedLoan] = await db
      .update(loans)
      .set({
        status: newStatus,
        statusChangedAt: new Date(),
        updatedAt: new Date(),
      })
      .where(eq(loans.id, id))
      .returning();

    return updatedLoan as Loan;
  }

  // ============ HYBRID MODEL METHODS ============

  /**
   * Add a co-borrower to a loan
   */
  static async addCoBorrower(
    loanId: string,
    borrowerId: string,
    role: BorrowerRole = BorrowerRole.CO_BORROWER
  ) {
    if (role === BorrowerRole.PRIMARY) {
      throw new Error("Use updateLoan() to change primary borrower");
    }

    const [relationship] = await db
      .insert(borrowerLoans)
      .values({
        borrowerId,
        loanId,
        role,
        isPrimary: false,
      })
      .onConflictDoNothing()
      .returning();

    return relationship;
  }

  /**
   * Add a participant lender to a loan (syndication)
   */
  static async addParticipantLender(
    loanId: string,
    lenderId: string,
    percentage: number
  ) {
    const [relationship] = await db
      .insert(lenderLoans)
      .values({
        lenderId,
        loanId,
        role: LenderRole.PARTICIPANT,
        isPrimary: false,
        percentage: percentage.toString(),
      })
      .onConflictDoNothing()
      .returning();

    return relationship;
  }

  /**
   * Get all borrowers for a loan (from junction table)
   */
  static async getLoanBorrowers(loanId: string) {
    const result = await db
      .select({
        borrower: borrowers,
        role: borrowerLoans.role,
        isPrimary: borrowerLoans.isPrimary,
      })
      .from(borrowerLoans)
      .innerJoin(borrowers, eq(borrowerLoans.borrowerId, borrowers.id))
      .where(eq(borrowerLoans.loanId, loanId));

    return result;
  }

  /**
   * Get all lenders for a loan (from junction table)
   */
  static async getLoanLenders(loanId: string) {
    const result = await db
      .select({
        lender: lenders,
        role: lenderLoans.role,
        isPrimary: lenderLoans.isPrimary,
        percentage: lenderLoans.percentage,
      })
      .from(lenderLoans)
      .innerJoin(lenders, eq(lenderLoans.lenderId, lenders.id))
      .where(eq(lenderLoans.loanId, loanId));

    return result;
  }

  // ============ DOCUMENT METHODS ============

  /**
   * Create a loan document
   */
  static async createDocument(data: CreateLoanDocumentDTO): Promise<LoanDocument> {
    const [document] = await db
      .insert(loanDocuments)
      .values({
        loanId: data.loanId,
        documentType: data.documentType,
        fileName: data.fileName,
        fileUrl: data.fileUrl,
        fileSize: data.fileSize || null,
        uploadedBy: data.uploadedBy || null,
      })
      .returning();

    return document as LoanDocument;
  }

  /**
   * Get all documents for a loan
   */
  static async getDocuments(loanId: string): Promise<LoanDocument[]> {
    const documents = await db
      .select()
      .from(loanDocuments)
      .where(eq(loanDocuments.loanId, loanId))
      .orderBy(desc(loanDocuments.uploadedAt));

    return documents as LoanDocument[];
  }

  /**
   * Delete a loan document
   */
  static async deleteDocument(id: string): Promise<boolean> {
    await db.delete(loanDocuments).where(eq(loanDocuments.id, id));
    return true;
  }

  // ============ NOTE METHODS ============

  /**
   * Create a loan note
   */
  static async createNote(data: CreateLoanNoteDTO): Promise<LoanNote> {
    const [note] = await db
      .insert(loanNotes)
      .values({
        loanId: data.loanId,
        content: data.content,
        createdBy: data.createdBy,
      })
      .returning();

    return note as LoanNote;
  }

  /**
   * Get all notes for a loan
   */
  static async getNotes(loanId: string): Promise<LoanNote[]> {
    const notes = await db
      .select()
      .from(loanNotes)
      .where(eq(loanNotes.loanId, loanId))
      .orderBy(desc(loanNotes.createdAt));

    return notes as LoanNote[];
  }

  /**
   * Update a loan note
   */
  static async updateNote(id: string, data: UpdateLoanNoteDTO): Promise<LoanNote | null> {
    const [note] = await db
      .update(loanNotes)
      .set({
        content: data.content,
        updatedAt: new Date(),
      })
      .where(eq(loanNotes.id, id))
      .returning();

    return (note as LoanNote) || null;
  }

  /**
   * Delete a loan note
   */
  static async deleteNote(id: string): Promise<boolean> {
    await db.delete(loanNotes).where(eq(loanNotes.id, id));
    return true;
  }
}

