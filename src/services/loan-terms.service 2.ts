/*
 File Header (auto-generated by scripts/add-file-headers.ts)
 - File: services/loan-terms.service 2.ts
 - Purpose: Domain service for data access and business logic.
 - Context: Mediates between API routes/UI and the database layer.
 - How it works: Implements domain logic and orchestrates database calls with clear input/output types. Uses: Drizzle ORM.
 - External imports: drizzle-orm
 - Local imports: @/db/client, @/db/schema
 - Refactoring ideas: Define transaction boundaries explicitly. | Return typed result objects instead of throwing. | Isolate DB access behind repository helpers.
 - Security considerations: Use parameterized queries to prevent injection. | Do not log sensitive data. | Handle concurrency and race conditions explicitly.
*/
import { eq } from "drizzle-orm";
import { db } from "@/db/client";
import { loanTerms } from "@/db/schema";

export interface LoanTerms {
  loanId: string;
  amortizationMonths: number | null;
  compounding: string | null;
  notes: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface CreateLoanTermsDTO {
  loanId: string;
  amortizationMonths?: number;
  compounding?: "simple" | "compound";
  notes?: string;
}

export interface UpdateLoanTermsDTO {
  amortizationMonths?: number;
  compounding?: "simple" | "compound";
  notes?: string;
}

export class LoanTermsService {
  /**
   * Create loan terms record
   */
  static async createLoanTerms(data: CreateLoanTermsDTO): Promise<LoanTerms> {
    const [record] = await db
      .insert(loanTerms)
      .values({
        loanId: data.loanId,
        amortizationMonths: data.amortizationMonths || null,
        compounding: data.compounding || null,
        notes: data.notes || null,
      })
      .returning();

    return record as LoanTerms;
  }

  /**
   * Get loan terms by loan ID
   */
  static async getByLoanId(loanId: string): Promise<LoanTerms | null> {
    const [record] = await db
      .select()
      .from(loanTerms)
      .where(eq(loanTerms.loanId, loanId))
      .limit(1);

    return (record as LoanTerms) || null;
  }

  /**
   * Update loan terms
   */
  static async updateLoanTerms(
    loanId: string,
    data: UpdateLoanTermsDTO
  ): Promise<LoanTerms | null> {
    const updateData: Record<string, unknown> = {
      updatedAt: new Date(),
    };

    if (data.amortizationMonths !== undefined)
      updateData.amortizationMonths = data.amortizationMonths;
    if (data.compounding !== undefined)
      updateData.compounding = data.compounding;
    if (data.notes !== undefined) updateData.notes = data.notes;

    const [updated] = await db
      .update(loanTerms)
      .set(updateData)
      .where(eq(loanTerms.loanId, loanId))
      .returning();

    return (updated as LoanTerms) || null;
  }

  /**
   * Delete loan terms
   */
  static async deleteLoanTerms(loanId: string): Promise<boolean> {
    await db.delete(loanTerms).where(eq(loanTerms.loanId, loanId));
    return true;
  }
}

