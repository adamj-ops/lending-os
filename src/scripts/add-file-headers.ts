/*
  File Header Generator
  - Recursively scans all .ts and .tsx files under src
  - Prepends a structured header comment if missing
  - Heuristically describes purpose, context, workings, imports, refactoring and security notes

  Safe to run multiple times; skips files already containing the marker.
*/

import fs from 'fs';
import path from 'path';

type FileCategory =
  | 'api'
  | 'page'
  | 'layout'
  | 'middleware'
  | 'component'
  | 'hook'
  | 'service'
  | 'db-schema'
  | 'db'
  | 'provider'
  | 'navigation'
  | 'types'
  | 'lib'
  | 'module';

const WORKSPACE_ROOT = process.cwd();
const SRC_DIR = path.join(WORKSPACE_ROOT, 'src');
const HEADER_MARKER = 'File Header (auto-generated by scripts/add-file-headers.ts)';

function listSourceFiles(startDir: string): string[] {
  const results: string[] = [];

  const stack: string[] = [startDir];
  while (stack.length) {
    const dir = stack.pop()!;
    let entries: fs.Dirent[] = [];
    try {
      entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
      continue;
    }
    for (const entry of entries) {
      const full = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        stack.push(full);
      } else if (entry.isFile()) {
        if (full.endsWith('.ts') || full.endsWith('.tsx')) {
          results.push(full);
        }
      }
    }
  }
  return results;
}

function detectCategory(filePath: string, contents: string): FileCategory {
  const rel = path.relative(SRC_DIR, filePath).replace(/\\/g, '/');
  if (rel.startsWith('app/api/')) return 'api';
  if (rel === 'middleware.ts') return 'middleware';
  if (rel.startsWith('app/')) {
    if (/\/layout\.tsx$/.test(rel)) return 'layout';
    if (/\/page\.tsx$/.test(rel)) return 'page';
  }
  if (rel.startsWith('components/')) return 'component';
  if (rel.startsWith('hooks/')) return 'hook';
  if (rel.startsWith('services/')) return 'service';
  if (rel.startsWith('db/schema')) return 'db-schema';
  if (rel.startsWith('db/')) return 'db';
  if (rel.startsWith('providers/')) return 'provider';
  if (rel.startsWith('navigation/')) return 'navigation';
  if (rel.startsWith('types/')) return 'types';
  if (rel.startsWith('lib/')) return 'lib';
  return 'module';
}

function getRouteFromAppPath(relPath: string): string | null {
  // Convert app router filesystem path to URL-ish route
  // Example: app/(main)/dashboard/loans/page.tsx -> /dashboard/loans
  const noPrefix = relPath.replace(/^app\//, '');
  // Strip route groups like (main)
  const parts = noPrefix.split('/').filter((p) => !/^\(.*\)$/.test(p));
  // Remove leaf file
  const file = parts.pop() ?? '';
  if (!file.endsWith('.tsx') && !file.endsWith('.ts')) return null;
  if (file === 'page.tsx') return '/' + parts.join('/');
  if (file === 'layout.tsx') return '/' + parts.join('/') + ' (layout)';
  return '/' + parts.join('/');
}

function extractImports(contents: string) {
  const importRegex = /import\s+[\s\S]*?from\s+['"]([^'\"]+)['"];?/g;
  const all: string[] = [];
  for (const match of contents.matchAll(importRegex)) {
    all.push(match[1]);
  }
  const local = Array.from(
    new Set(
      all.filter((m) => m.startsWith('./') || m.startsWith('../') || m.startsWith('@/'))
    )
  ).slice(0, 12);
  const external = Array.from(
    new Set(all.filter((m) => !m.startsWith('./') && !m.startsWith('../') && !m.startsWith('@/')))
  ).slice(0, 12);
  return { local, external };
}

function detectTechnologies(contents: string): string[] {
  const tech: string[] = [];
  if (contents.includes("'use client'") || contents.includes('"use client"')) tech.push('React Client Component');
  if (contents.includes("'use server'") || contents.includes('"use server"')) tech.push('React Server Action');
  if (/from\s+['"]next\//.test(contents)) tech.push('Next.js App Router');
  if (/from\s+['"]drizzle-orm['"]/.test(contents)) tech.push('Drizzle ORM');
  if (/from\s+['"]@tanstack\/react-query['"]/.test(contents)) tech.push('TanStack Query');
  if (/from\s+['"]zod['"]/.test(contents)) tech.push('Zod');
  if (/from\s+['"]react-hook-form['"]/.test(contents)) tech.push('React Hook Form');
  if (/from\s+['"]@aws-sdk\//.test(contents)) tech.push('AWS SDK');
  if (/from\s+['"]ai(\/|['"]).*/.test(contents)) tech.push('ai-sdk');
  return tech;
}

function describePurpose(rel: string, category: FileCategory): string {
  const base = path.basename(rel);
  if (category === 'api') {
    const resource = rel.replace(/^app\/api\//, '').replace(/\/route\.ts$/, '');
    return `HTTP route handlers for ${resource} (App Router API).`;
  }
  if (category === 'page') {
    const route = getRouteFromAppPath(rel) ?? `/${path.dirname(rel).replace(/^app\//, '')}`;
    return `Next.js page for ${route}.`;
  }
  if (category === 'layout') return 'Next.js layout wrapper for a route subtree.';
  if (category === 'middleware') return 'Edge middleware that runs before requests.';
  if (category === 'component') return `Reusable React UI component ${base}.`;
  if (category === 'hook') return `Custom React hook ${base.replace(/\.tsx?$/, '')}.`;
  if (category === 'service') return `Domain service for data access and business logic.`;
  if (category === 'db-schema') return 'Database schema and table definitions (Drizzle ORM).';
  if (category === 'db') return 'Database utilities, clients, and scripts.';
  if (category === 'provider') return 'React provider for shared app context/state.';
  if (category === 'navigation') return 'Navigation structure and sidebar configuration.';
  if (category === 'types') return 'Shared TypeScript types and interfaces.';
  if (category === 'lib') return 'Shared utilities and cross-cutting concerns.';
  return `Module ${base} supporting application features.`;
}

function describeContext(category: FileCategory): string {
  switch (category) {
    case 'api':
      return 'Exposes server-side endpoints consumed by UI and external clients.';
    case 'page':
    case 'layout':
      return 'Participates in the app router hierarchy for end-user navigation.';
    case 'component':
      return 'Composes UI from smaller primitives and domain data.';
    case 'hook':
      return 'Encapsulates reusable view or data-fetching logic.';
    case 'service':
      return 'Mediates between API routes/UI and the database layer.';
    case 'db-schema':
    case 'db':
      return 'Defines and interacts with the persistence layer.';
    case 'provider':
      return 'Supplies shared state and configuration to component trees.';
    case 'navigation':
      return 'Controls navigational structure and contextual links.';
    case 'types':
      return 'Ensures type safety across modules and features.';
    case 'lib':
      return 'Implements cross-cutting helpers used by multiple features.';
    default:
      return 'Supports a feature area and composes with adjacent modules.';
  }
}

function describeHowItWorks(category: FileCategory, technologies: string[]): string {
  const tech = technologies.length ? ` Uses: ${technologies.join(', ')}.` : '';
  switch (category) {
    case 'api':
      return 'Exports HTTP method handlers (e.g., GET/POST) that validate input, call services, and return structured JSON responses.' + tech;
    case 'page':
      return 'Defines a React component rendered by the app router; fetches and displays data via services/hooks.' + tech;
    case 'layout':
      return 'Wraps child routes, providing shared UI (headers, navigation) and context providers.' + tech;
    case 'middleware':
      return 'Executes at the edge per request for routing, auth checks, or response rewriting.' + tech;
    case 'component':
      return 'Renders UI based on props and context; defers side effects to hooks.' + tech;
    case 'hook':
      return 'Abstracts stateful logic and effects behind a stable API for components.' + tech;
    case 'service':
      return 'Implements domain logic and orchestrates database calls with clear input/output types.' + tech;
    case 'db-schema':
      return 'Declares tables, columns, and relationships; migrations align the database to these definitions.' + tech;
    case 'db':
      return 'Initializes DB clients and runs maintenance scripts (migrate/seed/clear).' + tech;
    case 'provider':
      return 'Initializes shared state and exposes it via React context to descendants.' + tech;
    case 'navigation':
      return 'Exports structural data used to render navigation menus and route groups.' + tech;
    case 'types':
      return 'Provides shared data contracts to prevent type drift across modules.' + tech;
    case 'lib':
      return 'Collects stateless helpers for formatting, configuration, I/O, or integration.' + tech;
    default:
      return 'Provides supporting logic composed by higher-level modules.' + tech;
  }
}

function describeRefactoring(category: FileCategory): string[] {
  switch (category) {
    case 'api':
      return [
        'Centralize input validation schemas and response helpers.',
        'Enforce consistent error typing and status codes.',
        'Consider rate limiting and per-user quotas.',
      ];
    case 'page':
    case 'component':
      return [
        'Split complex components into smaller units.',
        'Memoize expensive subtrees and handlers.',
        'Extract data fetching into hooks/services.',
      ];
    case 'hook':
      return [
        'Stabilize dependencies and memoize returned values.',
        'Expose minimal surface area with clear naming.',
      ];
    case 'service':
      return [
        'Define transaction boundaries explicitly.',
        'Return typed result objects instead of throwing.',
        'Isolate DB access behind repository helpers.',
      ];
    case 'db-schema':
    case 'db':
      return [
        'Add indexes for frequent query paths.',
        'Enforce constraints at the schema level.',
        'Document migration rationale and rollback plans.',
      ];
    case 'provider':
      return [
        'Scope providers narrowly to reduce re-renders.',
        'Ensure values are memoized to avoid churn.',
      ];
    case 'navigation':
      return ['Drive from a single source of truth for routes and labels.'];
    case 'types':
      return [
        'Prefer discriminated unions over stringly-typed fields.',
        'Use readonly where mutation is not intended.',
      ];
    case 'lib':
      return [
        'Consolidate overlapping utilities with consistent naming.',
        'Add unit tests to validate tricky edge cases.',
      ];
    default:
      return ['Align with module boundaries and update tests accordingly.'];
  }
}

function describeSecurity(category: FileCategory): string[] {
  switch (category) {
    case 'api':
      return [
        'Validate and sanitize all inputs; enforce authorization checks.',
        'Avoid leaking sensitive fields in responses.',
        'Consider rate limiting and audit logging.',
      ];
    case 'page':
    case 'component':
      return [
        'Avoid dangerouslySetInnerHTML; sanitize any HTML content.',
        'Do not embed secrets or tokens in client code.',
        'Harden forms against CSRF where applicable.',
      ];
    case 'hook':
      return ['Prevent accidental exposure of secrets to the client side.'];
    case 'service':
      return [
        'Use parameterized queries to prevent injection.',
        'Do not log sensitive data.',
        'Handle concurrency and race conditions explicitly.',
      ];
    case 'db-schema':
    case 'db':
      return [
        'Constrain data with not-null and foreign keys.',
        'Protect PII with encryption at rest where needed.',
      ];
    case 'provider':
      return ['Scope sensitive data carefully; avoid passing secrets via context.'];
    case 'navigation':
      return ['Hide links based on authorization; avoid enumerating resources.'];
    case 'types':
      return ['Mark sensitive fields and avoid accidental serialization.'];
    case 'lib':
      return ['Guard external I/O and sanitize any deserialized inputs.'];
    default:
      return ['Follow least-privilege and avoid leaking implementation details.'];
  }
}

function buildHeader(
  rel: string,
  category: FileCategory,
  contents: string
): string {
  const technologies = detectTechnologies(contents);
  const { local, external } = extractImports(contents);
  const purpose = describePurpose(rel, category);
  const context = describeContext(category);
  const how = describeHowItWorks(category, technologies);
  const refactor = describeRefactoring(category);
  const security = describeSecurity(category);

  const lines: string[] = [];
  lines.push('/*');
  lines.push(` File Header (auto-generated by scripts/add-file-headers.ts)`);
  lines.push(` - File: ${rel}`);
  lines.push(` - Purpose: ${purpose}`);
  lines.push(` - Context: ${context}`);
  lines.push(` - How it works: ${how}`);
  if (external.length)
    lines.push(` - External imports: ${external.join(', ')}`);
  if (local.length)
    lines.push(` - Local imports: ${local.join(', ')}`);
  if (refactor.length)
    lines.push(` - Refactoring ideas: ${refactor.join(' | ')}`);
  if (security.length)
    lines.push(` - Security considerations: ${security.join(' | ')}`);
  lines.push('*/');
  return lines.join('\n');
}

function shouldSkip(contents: string): boolean {
  return contents.includes(HEADER_MARKER);
}

function insertHeader(contents: string, header: string): string {
  // Keep any leading shebang if present, then insert header, then the rest
  const hasShebang = contents.startsWith('#!');
  if (hasShebang) {
    const nl = contents.indexOf('\n');
    const firstLine = contents.slice(0, nl + 1);
    const rest = contents.slice(nl + 1);
    return `${firstLine}${header}\n${rest}`;
  }
  // Preserve "use client"/"use server" directives at top of file
  const directiveMatch = contents.match(/^([\"\']use (client|server)[\"\']\s*;?\s*\n)/);
  if (directiveMatch) {
    const directive = directiveMatch[1];
    const rest = contents.slice(directive.length);
    return `${directive}${header}\n${rest}`;
  }
  return `${header}\n${contents}`;
}

function run() {
  if (!fs.existsSync(SRC_DIR)) {
    console.error('src directory not found');
    process.exit(1);
  }

  const files = listSourceFiles(SRC_DIR);
  let updated = 0;
  for (const file of files) {
    try {
      const rel = path.relative(SRC_DIR, file).replace(/\\/g, '/');
      const contents = fs.readFileSync(file, 'utf8');
      if (shouldSkip(contents)) continue;
      const category = detectCategory(file, contents);
      const header = buildHeader(rel, category, contents);
      const next = insertHeader(contents, header);
      fs.writeFileSync(file, next, 'utf8');
      updated += 1;
    } catch (err) {
      console.warn('Failed to process', file, err instanceof Error ? err.message : String(err));
    }
  }
  console.log(`Updated headers for ${updated} files.`);
}

run();
